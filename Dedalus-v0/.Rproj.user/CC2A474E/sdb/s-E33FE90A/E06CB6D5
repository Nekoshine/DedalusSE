{
    "collab_server" : "",
    "contents" : "\n /**\n * @file game.c\n * @author Chevelu Jonathan (jonathan.chevelu@irisa.fr)\n * @brief Dedalus game controller.\n * @version 0.1\n * @date 2019-01-25\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n#include <stdio.h>   // printf\n#include <string.h>  // strcpy, strlen\n#include <unistd.h>  // usleep\n\n#include \"display.h\"  // outputs of the game\n#include \"game.h\"     // public defintions\n#include \"gps.h\"      // pos_t\n#include <sys/types.h>\n#include <sys/wait.h>\n\n\n/**********************************/\n// Declaration of local functions.\n\n/**\n * @brief Structure to store moves propositions.\n *\n */\ntypedef struct moves_prop {\n  character_t* c;  ///< Pointer to the character concerned.\n  compass_t move;  ///< The move proposition\n  bool cheated;    ///< Is this a cheat move.\n} moves_prop_t;\n\n/**\n * @brief Initialize a moves propositions array.\n *\n * @param[in] pGame The game considered.\n * @param[out] pMoves Allocated array of moves propositions for each character.\n * @param[out] pNbChar Size of the array.\n * @warning The returned array must be free.\n */\nvoid _game_init_moves_prop(const game_t* pGame,\n                           moves_prop_t** pMoves,\n                           size_t* pNbChar);\n\n/**\n * @brief Get all moves propositions for each character.\n *\n * @param[in] pGame The game considered.\n * @param[in,out] pMoves An initialized vector of propositions.\n * @param[in] nbChar Number of character considered.\n * @note The array pMoves must be initialized before the call.\n */\nvoid _game_get_moves_propositions(game_t* pGame,\n                                  moves_prop_t* pMoves,\n                                  size_t nbChar);\n\n/**\n * @brief Solve conflicts between an array of move propositions.\n *\n * @param[in] pGame The game considered.\n * @param[in,out] moves The array of moves propositions to clear.\n * @param[in] nbChar Number of character considered.\n *\n * The \"moves\" arrays will be cleaned to remove conflicts.\n * A conflict occurs when two characters want to go at the same position.\n * In this version only one character will move (players firsts and in order\n * of declaration after).\n */\nvoid _gave_solve_moves_conflicts(const game_t* pGame,\n                                 moves_prop_t* moves,\n                                 size_t nbChar);\n\n/**\n * @brief Set a character as dead for this game.\n *\n * @param[in,out] pGame The game to change.\n * @param[in] pC The character to define has dead.\n */\nvoid _game_death_caractere(game_t* pGame, character_t* pC);\n\n/**\n * @brief A player exits the dedalus.\n *\n * @param[in, out] pGame The game to change.\n * @param[in, out] pC The player that exits.\n * @note The character must be a player. Otherwise it exits with a fatal error.\n */\nvoid _game_exit_character(game_t* pGame, character_t* pC);\n\n/**\n * @brief Says if two character should fight eachother.\n *\n * @param[in] pC1 A character.\n * @param[in] pC2 A character.\n * @return true A fight should take place.\n * @return false No fight possible.\n * @note A fight is possible if the characters are not dead, not of the same\n * type (one player vs one minotaur) and if they are at the same or an adjacent\n * position.\n */\nbool _game_should_fight(const character_t* pC1, const character_t* pC2);\n\n/**\n * @brief Run and display a fight between two characters.\n *\n * @param[in, out] pGame The game to change.\n * @param[in, out] pC1 First opponent.\n * @param[in, out] pC2 Second opponent.\n * @note This function never checks if the two characters should fight.\n */\nvoid _game_fight(game_t* pGame, character_t* pC1, character_t* pC2);\n\n/**\n * @brief Check and run all fights for a given character.\n *\n * @param[in, out] pGame The game to change.\n * @param[in, out] pC The concerned character.\n */\nvoid _game_fight_manager_char(game_t* pGame, character_t* pC);\n\n/**\n * @brief Check and run all fights for all characters.\n *\n * @param[in, out] pGame The game to change.\n */\nvoid _game_fight_manager(game_t* pGame);\n\n/**\n * @brief Define and set the target for a given character according to the board\n * configuration.\n *\n * @param[in, out] pGame The game to change.\n * @param[in] pC The charactere to find a target.\n * @return pos_t The position of the target for this character.\n * @note The target is the closest opponent if any. Else it is the closest exit\n * for a player.\n */\npos_t _game_character_target(game_t* pGame, const character_t* pC);\n\n/**\n * @brief Play a character move\n *\n * @param[in, out] pGame The game to change.\n * @param[in,out] pC The character to play.\n * @param[in] move The move to play.\n * @param[in] cheated The AI tries to cheat when move proposition was asked.\n * @param[in] cheated Says if the AI tries to cheat.\n */\nvoid _game_play_character(game_t* pGame,\n                          character_t* pC,\n                          compass_t move,\n                          bool cheated);\n\n/**\n * @brief Play all characters according to a set of moves.\n *\n * @param[in,out] pGame The game to change.\n * @param[in] moves Array of moves to play.\n * @param[in] nbChar Number of characters considered.\n */\nvoid _game_play_characters(game_t* pGame,\n                           const moves_prop_t* moves,\n                           size_t nbChar);\n\n/**\n * @brief Refresh display for everybody.\n *\n * @param[in] pGame The game to display.\n */\nvoid _game_play_refresh_ui(const game_t* pGame);\n\n/**\n * @brief Compute the end game status (win or loose) for the game master.\n *\n * @param[in] pGame The game considered.\n * @return ending_t An ending for the GM.\n */\nending_t _game_ending_gm(const game_t* pGame);\n\n/**\n * @brief Compute the end game status (win or loose) for a player.\n *\n * @param[in] pGame The game considered.\n * @param[in] pC The player considered.\n * @return ending_t An ending for the player.\n *\n * Returns the global ending i.e. how successful was the player team\n * considering the player personal result.\n */\nending_t _game_ending_player(const game_t* pGame, const character_t* pC);\n\n/*****************************/\n// Functions implementation.\n\nvoid _game_init_moves_prop(const game_t* pGame,\n                           moves_prop_t** pMoves,\n                           size_t* pNbChar) {\n  *pNbChar = pGame->nbPlayer + pGame->nbMinotaur;\n  *pMoves = (moves_prop_t*)malloc((*pNbChar) * sizeof(moves_prop_t));\n  if (*pMoves == NULL) {\n    display_fatal_error(stderr, \"Error: malloc failed!\");\n    exit(EXIT_FAILURE);\n  }\n  \n  // Init\n  \n  for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n    (*pMoves)[i].c = &(pGame->playerA[i]);\n    (*pMoves)[i].cheated = false;\n    (*pMoves)[i].move = Stay;\n  }\n  size_t offset = pGame->nbPlayer;\n  for (size_t i = 0; i < pGame->nbMinotaur; ++i) {\n    (*pMoves)[i + offset].c = &(pGame->minotaurA[i]);\n    (*pMoves)[i + offset].cheated = false;\n    (*pMoves)[i + offset].move = Stay;\n  }\n}\n\nvoid _game_death_caractere(game_t* pGame, character_t* pC) {\n  switch (pC->type) {\n  case PLAYER:\n    pGame->nbPlayerAlive--;\n    pGame->nbPlayerOnBoard--;\n    break;\n  case MINOTAUR:\n    pGame->nbMinotaurAlive--;\n    break;\n  default:\n    display_fatal_error(DISPLAY, \"Try to kill something strange\\n\");\n  exit(EXIT_FAILURE);\n  }\n  character_is_dead(pGame->pMap, pC);\n}\n\nvoid _game_exit_character(game_t* pGame, character_t* pC) {\n  switch (pC->type) {\n  case PLAYER:\n    pGame->nbPlayerOnBoard--;\n    break;\n  default:\n    display_fatal_error(DISPLAY, \"Try to exit something strange\\n\");\n  exit(EXIT_FAILURE);\n  }\n  character_is_out(pGame->pMap, pC);\n}\n\nbool _game_should_fight(const character_t* pC1, const character_t* pC2) {\n  // not dead and same position or next to eachother\n  return ((pC1->type != DEAD) && (pC2->type != DEAD) &&\n          (((pC1->pos.x + 1 == pC2->pos.x) && (pC1->pos.y == pC2->pos.y)) ||\n          ((pC1->pos.x - 1 == pC2->pos.x) && (pC1->pos.y == pC2->pos.y)) ||\n          ((pC1->pos.x == pC2->pos.x) && (pC1->pos.y + 1 == pC2->pos.y)) ||\n          ((pC1->pos.x == pC2->pos.x) && (pC1->pos.y - 1 == pC2->pos.y)) ||\n          ((pC1->pos.x == pC2->pos.x) && (pC1->pos.y == pC2->pos.y))));\n}\n\nvoid _game_fight(game_t* pGame, character_t* pC1, character_t* pC2) {\n  size_t i = 0;\n  while ((pC1->health > 0) && (pC2->health > 0)) {\n    display_fight_iteration(pGame->pMap, pC1, pC2, (size_t)pGame->delay, i);\n    usleep((unsigned int)pGame->delay);\n    ++i;\n    --(pC1->health);\n    --(pC2->health);\n  }\n  display_fight_iteration(pGame->pMap, pC1, pC2, (size_t)pGame->delay, i);\n  \n  if (pC1->health <= 0) {\n    _game_death_caractere(pGame, pC1);\n  }\n  \n  if (pC2->health <= 0) {\n    _game_death_caractere(pGame, pC2);\n  }\n  display_wait_user(DISPLAY, \"Press any key to continue...\",\n                    pGame->interactive);\n  \n  // refresh display\n  display_fight_clear(pC1->stream);\n  display_ui_player(pGame->gameName, pC1->ai.name, pGame->pMap, pC1,\n                    pGame->delay, pGame->maxMoves, pGame->gameInfo, false,\n                    false);\n  display_fight_clear(pC2->stream);\n  display_ui_player(pGame->gameName, pC2->ai.name, pGame->pMap, pC2,\n                    pGame->delay, pGame->maxMoves, pGame->gameInfo, false,\n                    false);\n  \n  _game_play_refresh_ui(pGame);\n}\n\nvoid _game_fight_manager_char(game_t* pGame, character_t* pC) {\n  character_t* pOpponents = NULL;\n  size_t nbOpponents = 0;\n  switch (pC->type) {\n  case PLAYER:\n    pOpponents = pGame->minotaurA;\n    nbOpponents = pGame->nbMinotaur;\n    break;\n  case MINOTAUR:\n    pOpponents = pGame->playerA;\n    nbOpponents = pGame->nbPlayer;\n    break;\n  default:\n    break;\n  // No opponent\n  }\n  for (size_t i = 0; i < nbOpponents; ++i) {\n    if (_game_should_fight(pC, &(pOpponents[i]))) {\n      _game_fight(pGame, pC, &(pOpponents[i]));\n    }\n  }\n}\n\nvoid _game_fight_manager(game_t* pGame) {\n  // Players fight\n  for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n    _game_fight_manager_char(pGame, &(pGame->playerA[i]));\n  }\n  \n  // Minotaur fight (notice : should be useless)\n  for (size_t i = 0; i < pGame->nbMinotaur; ++i) {\n    _game_fight_manager_char(pGame, &(pGame->minotaurA[i]));\n  }\n}\n\npos_t _game_character_target(game_t* pGame, const character_t* pC) {\n  pos_t target;\n  \n  switch (pC->type) {\n  case PLAYER:\n    if ((pGame->finalLevel) && (pGame->nbMinotaurAlive > 0)) {\n      target =\n        gps_closest(pC->pos, pGame->minotaurA, pGame->nbMinotaur, MINOTAUR);\n    } else {\n      target = gps_closest(pC->pos, pGame->exitA,pGame->nbExit, EXIT);\n    }\n    break;\n  case MINOTAUR:\n    target = gps_closest(pC->pos, pGame->playerA, pGame->nbPlayer, PLAYER);\n    break;\n  default:\n    // No target\n    target = pC->pos;\n  }\n  return target;\n}\n\nvoid _game_get_moves_propositions(game_t* pGame,\n                                  moves_prop_t* pMoves,\n                                  size_t nbChar) {\n  pid_t pid[nbChar];\n  //printf(\"nbChar : %d\\n\",(int)nbChar);\n  compass_t move;\n  bool cheated;\n  int status;\n  for (size_t i=0;i < nbChar;i++) {\n    character_t* pC = pMoves[i].c;\n    \n    pid[i]=fork();\n    if(pid[i]==-1){\n      printf(\"ggmp failed \\n\");\n      exit(EXIT_FAILURE);\n    }\n    if(pid[i]==0){\n      move = character_propose_move(pC, pGame->pMap, &cheated);\n      move=(int)move+cheated*10;\n      exit(move);\n    }\n    if(pid[i]>0){\n      //printf(\"i : %d\\n\",(int)i); \n      //Le probleme la cest que j'ai des tours de boucles dans le vide alors que ca devrait pas je pense que mon wait marche pas et que j attends pas la mort de mon fils  IDK WHY \n      \n      waitpid(pid[i],&status,WNOHANG);\n        \n       status=WEXITSTATUS(status);\n      //printf(\"status : %d\\n\",status);\n      pMoves[i].move=status%10;\n      pMoves[i].cheated=status/10;\n      //printf(\"move : %d cheated : %d\\n\",pMoves[i].move,pMoves[i].cheated);\n    }\n  }\n}\n\nvoid _gave_solve_moves_conflicts(const game_t* pGame,\n                                 moves_prop_t* moves,\n                                 size_t nbChar) {\n  (void)pGame;  // unused\n  \n  // Solve all conflicts\n  bool conflictFound = false;\n  do {\n    pos_t* usedPositions = NULL;\n    size_t nbPosUsed = 0;\n    // Fix position of staying char\n    for (size_t i = 0; i < nbChar; ++i) {\n      character_t* pC = moves[i].c;\n      // Only alive characters are interested\n      if ((moves[i].move == Stay) &&\n          ((pC->type == PLAYER) || (pC->type == MINOTAUR))) {\n        // reserve position. We are sure there is no conflict.\n        ++nbPosUsed;\n        usedPositions =\n        (pos_t*)realloc(usedPositions, nbPosUsed * sizeof(pos_t));\n        if (usedPositions == NULL) {\n          display_fatal_error(stderr, \"Error: can not realloc usedPosition!\");\n          exit(EXIT_FAILURE);\n        }\n        usedPositions[nbPosUsed - 1] = pC->pos;\n      }\n    }\n    \n    // Search conflict for others but stop at first conflict\n    // Just one conflict at a time in order to be sure that refusing a move for\n    // a character will not create another conflict.\n    conflictFound = false;\n    size_t i = 0;\n    while ((!conflictFound) && (i < nbChar)) {\n      character_t* pC = moves[i].c;\n      // Only alive characters are interested\n      // We only consider moving characters since those staying are already\n      // managed.\n      if ((moves[i].move != Stay) &&\n          ((pC->type == PLAYER) || (pC->type == MINOTAUR))) {\n        // Compute target position\n        pos_t nextPos = gps_compute_move(pC->pos, moves[i].move);\n        \n        // Check if we have a conflict\n        size_t j = 0;\n        while ((!conflictFound) && (j < nbPosUsed)) {\n          conflictFound = ((usedPositions[j].x == nextPos.x) &&\n            (usedPositions[j].y == nextPos.y));\n          ++j;\n        }\n        ++nbPosUsed;\n        usedPositions =\n        (pos_t*)realloc(usedPositions, nbPosUsed * sizeof(pos_t));\n        if (usedPositions == NULL) {\n          display_fatal_error(stderr, \"Error: can not realloc usedPosition!\");\n          exit(EXIT_FAILURE);\n        }\n        if (conflictFound) {\n          moves[i].move = Stay;\n          usedPositions[nbPosUsed - 1] = pC->pos;\n        } else {\n          // Reserve the position\n          usedPositions[nbPosUsed - 1] = nextPos;\n        }\n      }\n      ++i;\n    }\n    \n    free(usedPositions);\n  } while (conflictFound);\n}\n\nvoid _game_play_character(game_t* pGame,\n                          character_t* pC,\n                          compass_t move,\n                          bool cheated) {\n  bool exited = false;\n  \n  if (cheated) {\n    // Deal with cheater\n    _game_death_caractere(pGame, pC);\n    if (pGame->nbMinotaurAlive > 0) {\n      pC->ending = EC_CHEAT_MINOTAUR;\n    } else {\n      pC->ending = EC_CHEAT_NO_MINOTAUR;\n    }\n  } else {\n    // Move character\n    pos_t target = _game_character_target(pGame, pC);\n    character_play(pC, move, target, pGame->pMap, pGame->steps, pGame->maxMoves,\n                   &exited);\n    \n    if ((pC->type != DEAD) && (pC->health <= 0)) {\n      // Deal with exhaustion\n      _game_death_caractere(pGame, pC);\n      if (pGame->nbMinotaurAlive > 0) {\n        pC->ending = EC_STARVE_MINOTAUR;\n      } else {\n        pC->ending = EC_STARVE_NO_MINOTAUR;\n      }\n    }\n  }\n  \n  // Deal with exit\n  if (exited && (pC->type == PLAYER) && (pGame->nbMinotaurAlive <= 0)) {\n    // NOTE: if you kill the last Minotaur on an exit tile, you have to move\n    // twice to exit.\n    \n    // NOTE: you can't exit if you are dead.\n    _game_exit_character(pGame, pC);\n    if (pGame->finalLevel) {\n      pC->ending = EC_WIN;\n    } else {\n      pC->ending = EC_ESCAPE;\n    }\n  }\n}\n\nvoid _game_play_characters(game_t* pGame,\n                           const moves_prop_t* moves,\n                           size_t nbChar) {\n  // Play all characters\n  for (size_t i = 0; i < nbChar; ++i) {\n    _game_play_character(pGame, moves[i].c, moves[i].move, moves[i].cheated);\n  }\n}\n\nvoid _game_play_refresh_ui(const game_t* pGame) {\n  // Play all characters\n  \n  // Display current state for game master\n  display_ui_gm(DISPLAY, pGame->gameName, pGame->pMap, pGame->nbPlayerAlive,\n                pGame->nbPlayerOnBoard, pGame->nbMinotaurAlive, pGame->delay,\n                pGame->gameInfo, true);\n  for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n    const character_t* pC = &(pGame->playerA[i]);\n    // Display for current player\n    display_ui_player(pGame->gameName, pC->ai.name, pGame->pMap, pC,\n                      pGame->delay, pGame->maxMoves, pGame->gameInfo, false,\n                      true);\n  }\n}\n\nending_t _game_ending_gm(const game_t* pGame) {\n  if (pGame->nbPlayerAlive > 0) {\n    return EG_GM_LOOSE;\n  }\n  return EG_GM_WIN;\n}\n\nending_t _game_ending_player(const game_t* pGame, const character_t* pC) {\n  ending_t ending = EG_LOOSE;\n  if (pC->type == EXIT) {\n    if (pGame->finalLevel) {\n      ending = EG_WIN_AND_ALIVE;\n    } else {\n      ending = EG_NEXT_LEVEL_AND_ALIVE;\n    }\n  } else if (pGame->nbPlayerAlive > 0) {\n    if (!pGame->finalLevel) {\n      ending = EG_NEXT_LEVEL_BUT_DEAD;\n    } else if (pGame->nbMinotaurAlive <= 0) {\n      ending = EG_WIN_BUT_DEAD;\n    }  // else {} //  LOOSE\n  } else if ((pGame->nbMinotaurAlive <= 0) && (pGame->finalLevel)) {\n    ending = EG_KILL_MINOTAUR_BUT_DEAD;\n  }\n  return ending;\n}\n\n/**********************************/\n// Public functions implementations.\n\nbool game_init(game_t* pGame,\n               config_t* pConf,\n               const char* gameName,\n               map_t* pMap,\n               int pDefHealth,\n               ai_t pAi,\n               int mDefHealth,\n               ai_t mAi) {\n  pGame->gameName = gameName;\n  pGame->pMap = pMap;\n  pGame->maxMoves = pConf->maxMoves;\n  pGame->gameInfo = pConf->gameInfo;\n  pGame->steps = 0;\n  pGame->delay = pConf->delay;\n  pGame->interactive = pConf->interactive;\n  \n  bool ok = true;\n  \n  // Load exit(s)\n  pGame->nbExit = gps_locator(pMap, EXIT, &(pGame->exitA));\n  bool noExit = (pGame->nbExit == 0);\n  \n  // Load a Minotaur(s)\n  pos_t* mAPos = NULL;\n  pGame->nbMinotaur = gps_locator(pMap, MINOTAUR, &mAPos);\n  pGame->nbMinotaurAlive = pGame->nbMinotaur;\n  pGame->finalLevel = (pGame->nbMinotaur > 0);\n  if ((pGame->nbExit == 0) && (!pGame->finalLevel)) {\n    // if no exit, then it must be a final level\n    ok = false;\n  }\n  // NOTE: malloc(0) return NULL so it is ok\n  pGame->minotaurA =\n    (character_t*)malloc(pGame->nbMinotaur * sizeof(character_t));\n  for (size_t i = 0; i < pGame->nbMinotaur; ++i) {\n    pGame->minotaurA[i] = character_init(MINOTAUR, (pid_t)(-i - 1), false,\n                                         \"Minotaur\", mDefHealth, mAi);\n    pGame->minotaurA[i].pos = mAPos[i];\n    pGame->minotaurA[i].pMask = map_mask_init(pMap);\n    map_mask_add(pGame->minotaurA[i].pMask, mAPos[i]);\n    \n    // NOTE: Targets are not set yet\n  }\n  free(mAPos);\n  mAPos = NULL;\n  \n  // Load a player(s)\n  pos_t* pAPos = NULL;\n  pGame->nbPlayer = gps_locator(pMap, PLAYER, &pAPos);\n  pGame->nbPlayerAlive = pGame->nbPlayer;\n  pGame->nbPlayerOnBoard = pGame->nbPlayer;\n  if (pGame->nbPlayer == 0) {\n    // Need at least one player\n    ok = false;\n  }\n  pGame->playerA = (character_t*)malloc(pGame->nbPlayer * sizeof(character_t));\n  config_t config=config_init(); //-------------------------\n  pid_t display[pGame->nbPlayer]; //------------------------------------\n  for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n    // Get the display to use with this player.\n    usleep((unsigned int)pGame->delay);\n    display[i]=fork();\n    if(display[i]==-1){\n      return EXIT_FAILURE;\n    }\n    if(display[i]==0){\n      char geometry[20];\n      if(i<4){\n        sprintf(geometry,\"80x23+%d+0\",(int)(i%4)*400);\n      }else{\n        sprintf(geometry,\"80x23+%d-0\",(int)(i%4)*400);\n      }\n      execlp(\"xterm\",\"xterm\",\"-geometry\",geometry,NULL);\n    }\n    usleep((unsigned int)pGame->delay);\n    config_add_display(&config, display[i]+2); //------------------------------------\n    \n    // Init player\n    pGame->playerA[i] =\n      character_init(PLAYER, display[i], true, \"Theseus\", pDefHealth, pAi);\n    pGame->playerA[i].pos = pAPos[i];\n    pGame->playerA[i].pMask = map_mask_init(pMap);\n    map_mask_add(pGame->playerA[i].pMask, pAPos[i]);\n    // NOTE: Targets are not set yet\n  }\n  free(pAPos);\n  pAPos = NULL;\n  \n  // Add missing exit (if final)\n  if (ok && noExit && pGame->finalLevel) {\n    for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n      if ((pGame->playerA[i].pos.x == 0) || (pGame->playerA[i].pos.y == 0)) {\n        // add an exit\n        if (pGame->nbExit == 0) {\n          pGame->exitA = (pos_t*)malloc(1 * sizeof(pos_t));\n        } else {\n          pGame->exitA = (pos_t*)realloc(pGame->exitA,\n                          (pGame->nbExit + 1) * sizeof(pos_t));\n        }\n        pGame->exitA[pGame->nbExit].x = pGame->playerA[i].pos.x;\n        pGame->exitA[pGame->nbExit].y = pGame->playerA[i].pos.y;\n        pGame->playerA[i].walkOn = EXIT;\n        ++(pGame->nbExit);\n      }\n    }\n  }\n  if (pGame->nbExit == 0) {\n    ok = false;\n  }\n  \n  // Init targets\n  for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n    character_t* pC = &(pGame->playerA[i]);\n    gps_direction(pC->pos, _game_character_target(pGame, pC),\n                  &(pC->targetCompass), &(pC->targetDistance));\n  }\n  for (size_t i = 0; i < pGame->nbMinotaur; ++i) {\n    character_t* pC = &(pGame->minotaurA[i]);\n    gps_direction(pC->pos, _game_character_target(pGame, pC),\n                  &(pC->targetCompass), &(pC->targetDistance));\n  }\n  \n  return ok;\n}\n\nvoid game_start(game_t* pGame) {\n  // Print UI\n  \n  // Initial display for game master\n  display_ui_gm(DISPLAY, pGame->gameName, pGame->pMap, pGame->nbPlayerAlive,\n                pGame->nbPlayerOnBoard, pGame->nbMinotaurAlive, pGame->delay,\n                pGame->gameInfo, false);\n  \n  // Initial display for each player\n  for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n    const character_t* pC = &(pGame->playerA[i]);\n    display_ui_player(pGame->gameName, pC->ai.name, pGame->pMap, pC,\n                      pGame->delay, pGame->maxMoves, pGame->gameInfo, true,\n                      false);\n  }\n  \n  size_t nbChar = 0;\n  moves_prop_t* moves = NULL;\n  _game_init_moves_prop(pGame, &moves, &nbChar);\n  \n  do {\n    // Play characters\n    pGame->steps += 1;\n    usleep((unsigned int)pGame->delay);\n    \n    // Fights\n    _game_fight_manager(pGame);\n    \n    // Get characters move propositions\n    _game_get_moves_propositions(pGame, moves, nbChar);\n    // Solve confilcts\n    _gave_solve_moves_conflicts(pGame, moves, nbChar);\n    \n    // Play characters\n    _game_play_characters(pGame, moves, nbChar);\n    \n    // refresh displays\n    _game_play_refresh_ui(pGame);\n    \n    // Fights\n    _game_fight_manager(pGame);\n    \n  } while (pGame->nbPlayerOnBoard > 0);\n  \n  free(moves);\n  nbChar = 0;\n  \n  // The end\n  for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n    const character_t* pC = &(pGame->playerA[i]);\n    // Last display for each player\n    display_ending(pGame->playerA[i].stream, _game_ending_player(pGame, pC));\n  }\n  display_ending(DISPLAY, _game_ending_gm(pGame));\n}\n\nvoid game_delete(game_t* pGame) {\n  pGame->gameName = NULL;\n  \n  free(pGame->exitA);\n  pGame->exitA = NULL;\n  pGame->nbExit = 0;\n  \n  for (size_t i = 0; i < pGame->nbPlayer; ++i) {\n    character_delete(pGame->pMap, &(pGame->playerA[i]));\n  }\n  free(pGame->playerA);\n  pGame->playerA = NULL;\n  pGame->nbPlayer = 0;\n  pGame->nbPlayerAlive = 0;\n  pGame->nbPlayerOnBoard = 0;\n  \n  for (size_t i = 0; i < pGame->nbMinotaur; ++i) {\n    character_delete(pGame->pMap, &(pGame->minotaurA[i]));\n  }\n  free(pGame->minotaurA);\n  pGame->minotaurA = NULL;\n  pGame->nbMinotaur = 0;\n  pGame->nbMinotaurAlive = 0;\n  \n  pGame->finalLevel = false;\n  pGame->maxMoves = 0;\n  pGame->steps = 0;\n  pGame->delay = 0;\n  \n  map_delete(pGame->pMap);\n  pGame->pMap = NULL;\n}\n",
    "created" : 1553358755588.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "738735889",
    "id" : "E06CB6D5",
    "lastKnownWriteTime" : 1553361476,
    "last_content_update" : 1553361476473,
    "path" : "~/Dedalus/Dedalus-v2/src/game.c",
    "project_path" : null,
    "properties" : {
        "source_window_id" : "whoqlez9ye5tx"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "c"
}
{
    "collab_server" : "",
    "contents" : "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <time.h>\n#include \"avl.h\"\n\nint compteur=0;\n\nT_Tree init_Tree(){\n  return NULL;\n}\n\nT_Tree creer_noeud(int i){\n  T_Tree t = (T_node *) malloc(sizeof(T_node));\n  if (t!=NULL){\n    t -> val = i;\n    t -> g = NULL;\n    t -> d = NULL;\n    t -> eq = 0;\n    compteur+=6;\n  }\n  else{\n    printf(\"pbm allocation memoire!\\n\");\n  }\n  return t;\n}\n\nvoid lecture_arbre(T_Tree T){\n  if (T!=NULL){\n    printf(\"< \");\n    lecture_arbre(T -> g);\n    printf(\" , %d, \", T -> val);\n    lecture_arbre(T -> d);\n    printf(\">\");\n  }\n  else {\n    printf(\"<>\");\n  }\n}\n\n\n\nvoid rotation_g(T_Tree * T){\n // printf(\"rotation g \\n\");\n  // precondition : arbre de hauteur 1 avec son sous-arbre droit non vide\n  T_Tree dtmp;\n  dtmp = (*T)->d;\n  (*T)->d=dtmp->g;\n  dtmp->g=*T;\n  dtmp->eq = 0;\n  (*T)->eq = 0;\n  (*T) = dtmp;\n  compteur+=6;\n}\n\nvoid rotation_d(T_Tree * T){\n // printf(\"rotation d \\n\");\n  // precondition : arbre de hauteur 1 avec son sous-arbre gauche non vide\n  T_Tree gtmp;\n  \n  // init\n  gtmp = (*T)->g;\n  \n  // operation de rotation : completer\n  // ...\n  (*T)->g=gtmp->d;\n  gtmp->d=*T;\n  \n  // mise a jour des degres\n  \n  gtmp->eq = 0;\n  (*T)->eq = 0;\n  \n  (*T) = gtmp;\n  compteur+=6;\n}\n\n\nvoid rotation_d_g(T_Tree * T){\n  //printf(\"rotation d g \\n\");\n  // precondition : arbre de hauteur 2 avec son sous-arbre droit puis gauche non vide\n  T_Tree dtmp;\n  T_Tree gtmp;\n  \n  dtmp = (*T)->d;\n  gtmp = dtmp -> g;\n  \n  (*T)->d=gtmp->g;\n  dtmp->g=gtmp->d;\n  gtmp->g=*T;\n  gtmp->d=dtmp;\n  \n  switch(gtmp->eq) { \n  \n  case 1: \n    dtmp->eq = -1; \n    (*T)->eq = 0;\n    break; \n  case -1: \n    dtmp->eq = 0; \n    (*T)->eq = 1;\n    break; \n  case 0: \n    dtmp->eq = 0; \n    (*T)->eq = 0;\n    break;\n  }\n  gtmp->eq =0;\n  (*T) = gtmp;\n  compteur+=11;\n}\n\nvoid rotation_g_d(T_Tree * T){\n // printf(\"rotation g d \\n\");\n  // precondition : arbre de hauteur 2 avec son sous-arbre gauche puis sous sous-droit non vide\n  T_Tree gtmp;\n  T_Tree dtmp;\n  \n  //init\n  gtmp = (*T)->g;\n  dtmp = gtmp -> d;\n  \n  \n  (*T)->g=dtmp->d;\n  gtmp->d=dtmp->g;\n  dtmp->d=*T;\n  dtmp->g=gtmp;\n  \n  // mise a jour des degres\n  switch(dtmp->eq) { \n  \n  case 1: \n    gtmp->eq = 0; \n    (*T)->eq = -1;\n    break; \n  case -1: \n    gtmp->eq = 1; \n    (*T)->eq = 0;\n    break; \n  case 0: \n    gtmp->eq = 0; \n    (*T)->eq = 0; \n    break;\n  }\n  // mise a jour du degre de la future racine\n  dtmp->eq =0;\n  // mise a jour de l'arbre *T\n  (*T) = dtmp;\n  compteur+=11;\n}\n\nvoid insertion(T_Tree * T, int i, int * h){\n  if (*T==NULL){ // cas de base\n    (*T) = creer_noeud(i);\n    compteur+=2;\n    if (*T==NULL) {\n      printf(\"Allocation memoire impossible\\n\");\n      (*h) = 0;\n      compteur+=2;\n    }\n    else {(*h) = 1; compteur+=1;}\n  }\n  else { // HR : on sait inserer un element dans un arbre de hauteur plus petite\n    if (i < ((*T) -> val)) {\n      compteur+=1;\n      insertion(&((*T) -> g),i,h);\n      if (*h==1){\n        switch(((*T) -> eq)) { \n        case -1: \n          ((*T) -> eq) = 0;\n          *h = 0;\n          compteur+=3;\n          break;\n        case 0: \n          ((*T) -> eq) = 1;\n          *h = 1;\n          compteur+=3;\n          break;\n        case 1:\n          if ((((*T) -> g) -> eq) == 1){\n            // rotation simple vers la droite\n            rotation_d(T);\n            compteur+=1;\n          }\n          else {\n            // rotation double\n            rotation_g_d(T);\n            compteur+=1;\n          }\n          *h = 0; \n          compteur+=1;\n          break; \n        }\n      }\n    }\n    else {\n      // completer le cas d'insertion dans le sous-arbre droit\n      insertion(&((*T) -> d),i,h);\n      if (*h==1){\n        compteur+=1;\n        switch(((*T) -> eq)) { \n        case 1: \n          ((*T) -> eq) = 0;\n          *h = 0;\n          compteur+=3;\n          break;\n        case 0: \n          ((*T) -> eq) = -1;\n          *h = 1;\n          compteur+=3;\n          break;\n        case -1:\n          if ((((*T) -> d) -> eq) == -1){\n            // rotation simple vers la droite\n            rotation_g(T);\n            compteur+=1;\n          }\n          else {\n            // rotation double\n            rotation_d_g(T);\n          }\n          *h = 0; \n          compteur+=1;\n          break; \n        }\n      }\n    }\n  }\n}\n\nvoid insertion_feuille(T_Tree * T, int i) {\n  int h=0;\n  compteur+=1;\n  insertion(T,i,&h);\n}\n\n\n\nint main(void){\n  T_Tree a,b;\n  \n  a = init_Tree();\n  b = init_Tree();\n  srand((unsigned int ) time(NULL));\n  \n  for(int i=1;i<10000;i++) {\n   // printf(\"%d\\n\",rand()%100);\n  \n   insertion_feuille(&a,rand()%10000);\n  }\n // print_t(a);\n  printf(\"Cout %d\\n\",compteur);\n  return EXIT_SUCCESS;\n}\t",
    "created" : 1554194886819.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3474606725",
    "id" : "FD65DDD1",
    "lastKnownWriteTime" : 1554200561,
    "last_content_update" : 1554200562533,
    "path" : "~/SDD/tpavl/avl.c",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "c"
}